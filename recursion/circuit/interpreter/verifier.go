// This file is auto-generated by sp1-recursion-compiler.
package verifier

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"

	"github.com/consensys/gnark/frontend"
	"github.com/succinctlabs/sp1-recursion-gnark/babybear"
)

type Circuit struct {
	X frontend.Variable
	Y frontend.Variable
}

type Constraint struct {
	Opcode string     `json:"opcode"`
	Args   [][]string `json:"args"`
}

func (c Constraint) Dst() string {
	return c.Args[0][0]
}

func (circuit *Circuit) Define(api frontend.API) error {
	// Get the file name from an environment variable.
	fileName := os.Getenv("CONSTRAINT_JSON")
	if fileName == "" {
		return fmt.Errorf("CONSTRAINT_JSON environment variable is not set")
	}

	// Read the file.
	data, err := ioutil.ReadFile(fileName)
	if err != nil {
		return fmt.Errorf("failed to read file: %w", err)
	}

	// Deserialize the JSON data into a slice of Instruction structs
	var constraints []Constraint
	err = json.Unmarshal(data, &constraints)
	if err != nil {
		return fmt.Errorf("error deserializing JSON: %v", err)
	}

	var vars map[string]frontend.Variable
	var felts map[string]*babybear.Variable
	var exts map[string]*babybear.ExtensionVariable

	// Iterate through the instructions and handle each opcode
	for _, cs := range constraints {
		switch cs.Opcode {
		case "ImmV":
			vars[cs.Dst()] = frontend.Variable(cs.Args[1][0])
		case "ImmF":
			felts[cs.Dst()] = babybear.NewVariable(cs.Args[1][0])
		case "ImmE":
			exts[cs.Dst()] = babybear.NewExtensionVariable(cs.Args[1])
		default:
			return fmt.Errorf("unhandled opcode: %s", cs.Opcode)
		}
	}

	return nil
}
